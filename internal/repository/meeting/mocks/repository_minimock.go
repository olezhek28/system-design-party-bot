package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/olezhek28/system-design-party-bot/internal/repository/meeting.Repository -o ./mocks/repository_minimock.go -n RepositoryMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/olezhek28/system-design-party-bot/internal/model"
	mm_meeting_repository "github.com/olezhek28/system-design-party-bot/internal/repository/meeting"
)

// RepositoryMock implements meeting_repository.Repository
type RepositoryMock struct {
	t minimock.Tester

	funcCreate          func(ctx context.Context, meeting *model.Meeting) (i1 int64, err error)
	inspectFuncCreate   func(ctx context.Context, meeting *model.Meeting)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mRepositoryMockCreate

	funcGet          func(ctx context.Context, id int64) (mp1 *model.Meeting, err error)
	inspectFuncGet   func(ctx context.Context, id int64)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mRepositoryMockGet

	funcGetList          func(ctx context.Context, filter *mm_meeting_repository.Query) (mpa1 []*model.Meeting, err error)
	inspectFuncGetList   func(ctx context.Context, filter *mm_meeting_repository.Query)
	afterGetListCounter  uint64
	beforeGetListCounter uint64
	GetListMock          mRepositoryMockGetList

	funcGetSpeakerCountByTopic          func(ctx context.Context, topicID int64, speakerID int64) (i1 int64, err error)
	inspectFuncGetSpeakerCountByTopic   func(ctx context.Context, topicID int64, speakerID int64)
	afterGetSpeakerCountByTopicCounter  uint64
	beforeGetSpeakerCountByTopicCounter uint64
	GetSpeakerCountByTopicMock          mRepositoryMockGetSpeakerCountByTopic

	funcGetSpeakersStats          func(ctx context.Context, topicID int64, excludeSpeakerID int64) (spa1 []*model.Stats, err error)
	inspectFuncGetSpeakersStats   func(ctx context.Context, topicID int64, excludeSpeakerID int64)
	afterGetSpeakersStatsCounter  uint64
	beforeGetSpeakersStatsCounter uint64
	GetSpeakersStatsMock          mRepositoryMockGetSpeakersStats

	funcUpdate          func(ctx context.Context, ids []int64, updateMeeting *model.UpdateMeeting) (err error)
	inspectFuncUpdate   func(ctx context.Context, ids []int64, updateMeeting *model.UpdateMeeting)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mRepositoryMockUpdate
}

// NewRepositoryMock returns a mock for meeting_repository.Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*RepositoryMockCreateParams{}

	m.GetMock = mRepositoryMockGet{mock: m}
	m.GetMock.callArgs = []*RepositoryMockGetParams{}

	m.GetListMock = mRepositoryMockGetList{mock: m}
	m.GetListMock.callArgs = []*RepositoryMockGetListParams{}

	m.GetSpeakerCountByTopicMock = mRepositoryMockGetSpeakerCountByTopic{mock: m}
	m.GetSpeakerCountByTopicMock.callArgs = []*RepositoryMockGetSpeakerCountByTopicParams{}

	m.GetSpeakersStatsMock = mRepositoryMockGetSpeakersStats{mock: m}
	m.GetSpeakersStatsMock.callArgs = []*RepositoryMockGetSpeakersStatsParams{}

	m.UpdateMock = mRepositoryMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*RepositoryMockUpdateParams{}

	return m
}

type mRepositoryMockCreate struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateExpectation
	expectations       []*RepositoryMockCreateExpectation

	callArgs []*RepositoryMockCreateParams
	mutex    sync.RWMutex
}

// RepositoryMockCreateExpectation specifies expectation struct of the Repository.Create
type RepositoryMockCreateExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockCreateParams
	results *RepositoryMockCreateResults
	Counter uint64
}

// RepositoryMockCreateParams contains parameters of the Repository.Create
type RepositoryMockCreateParams struct {
	ctx     context.Context
	meeting *model.Meeting
}

// RepositoryMockCreateResults contains results of the Repository.Create
type RepositoryMockCreateResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for Repository.Create
func (mmCreate *mRepositoryMockCreate) Expect(ctx context.Context, meeting *model.Meeting) *mRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("RepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &RepositoryMockCreateExpectation{}
	}

	mmCreate.defaultExpectation.params = &RepositoryMockCreateParams{ctx, meeting}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the Repository.Create
func (mmCreate *mRepositoryMockCreate) Inspect(f func(ctx context.Context, meeting *model.Meeting)) *mRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for RepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by Repository.Create
func (mmCreate *mRepositoryMockCreate) Return(i1 int64, err error) *RepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("RepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &RepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &RepositoryMockCreateResults{i1, err}
	return mmCreate.mock
}

//Set uses given function f to mock the Repository.Create method
func (mmCreate *mRepositoryMockCreate) Set(f func(ctx context.Context, meeting *model.Meeting) (i1 int64, err error)) *RepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the Repository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the Repository.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the Repository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mRepositoryMockCreate) When(ctx context.Context, meeting *model.Meeting) *RepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("RepositoryMock.Create mock is already set by Set")
	}

	expectation := &RepositoryMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &RepositoryMockCreateParams{ctx, meeting},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up Repository.Create return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateExpectation) Then(i1 int64, err error) *RepositoryMock {
	e.results = &RepositoryMockCreateResults{i1, err}
	return e.mock
}

// Create implements meeting_repository.Repository
func (mmCreate *RepositoryMock) Create(ctx context.Context, meeting *model.Meeting) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, meeting)
	}

	mm_params := &RepositoryMockCreateParams{ctx, meeting}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_got := RepositoryMockCreateParams{ctx, meeting}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("RepositoryMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the RepositoryMock.Create")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, meeting)
	}
	mmCreate.t.Fatalf("Unexpected call to RepositoryMock.Create. %v %v", ctx, meeting)
	return
}

// CreateAfterCounter returns a count of finished RepositoryMock.Create invocations
func (mmCreate *RepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of RepositoryMock.Create invocations
func (mmCreate *RepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mRepositoryMockCreate) Calls() []*RepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateDone() bool {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.Create with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.Create")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.Create")
	}
}

type mRepositoryMockGet struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetExpectation
	expectations       []*RepositoryMockGetExpectation

	callArgs []*RepositoryMockGetParams
	mutex    sync.RWMutex
}

// RepositoryMockGetExpectation specifies expectation struct of the Repository.Get
type RepositoryMockGetExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockGetParams
	results *RepositoryMockGetResults
	Counter uint64
}

// RepositoryMockGetParams contains parameters of the Repository.Get
type RepositoryMockGetParams struct {
	ctx context.Context
	id  int64
}

// RepositoryMockGetResults contains results of the Repository.Get
type RepositoryMockGetResults struct {
	mp1 *model.Meeting
	err error
}

// Expect sets up expected params for Repository.Get
func (mmGet *mRepositoryMockGet) Expect(ctx context.Context, id int64) *mRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("RepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &RepositoryMockGetExpectation{}
	}

	mmGet.defaultExpectation.params = &RepositoryMockGetParams{ctx, id}
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the Repository.Get
func (mmGet *mRepositoryMockGet) Inspect(f func(ctx context.Context, id int64)) *mRepositoryMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for RepositoryMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by Repository.Get
func (mmGet *mRepositoryMockGet) Return(mp1 *model.Meeting, err error) *RepositoryMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("RepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &RepositoryMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &RepositoryMockGetResults{mp1, err}
	return mmGet.mock
}

//Set uses given function f to mock the Repository.Get method
func (mmGet *mRepositoryMockGet) Set(f func(ctx context.Context, id int64) (mp1 *model.Meeting, err error)) *RepositoryMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the Repository.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the Repository.Get method")
	}

	mmGet.mock.funcGet = f
	return mmGet.mock
}

// When sets expectation for the Repository.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mRepositoryMockGet) When(ctx context.Context, id int64) *RepositoryMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("RepositoryMock.Get mock is already set by Set")
	}

	expectation := &RepositoryMockGetExpectation{
		mock:   mmGet.mock,
		params: &RepositoryMockGetParams{ctx, id},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up Repository.Get return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetExpectation) Then(mp1 *model.Meeting, err error) *RepositoryMock {
	e.results = &RepositoryMockGetResults{mp1, err}
	return e.mock
}

// Get implements meeting_repository.Repository
func (mmGet *RepositoryMock) Get(ctx context.Context, id int64) (mp1 *model.Meeting, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, id)
	}

	mm_params := &RepositoryMockGetParams{ctx, id}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mp1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_got := RepositoryMockGetParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("RepositoryMock.Get got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the RepositoryMock.Get")
		}
		return (*mm_results).mp1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, id)
	}
	mmGet.t.Fatalf("Unexpected call to RepositoryMock.Get. %v %v", ctx, id)
	return
}

// GetAfterCounter returns a count of finished RepositoryMock.Get invocations
func (mmGet *RepositoryMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of RepositoryMock.Get invocations
func (mmGet *RepositoryMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mRepositoryMockGet) Calls() []*RepositoryMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*RepositoryMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetDone() bool {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.Get with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.Get")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.Get with params: %#v", *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.Get")
	}
}

type mRepositoryMockGetList struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetListExpectation
	expectations       []*RepositoryMockGetListExpectation

	callArgs []*RepositoryMockGetListParams
	mutex    sync.RWMutex
}

// RepositoryMockGetListExpectation specifies expectation struct of the Repository.GetList
type RepositoryMockGetListExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockGetListParams
	results *RepositoryMockGetListResults
	Counter uint64
}

// RepositoryMockGetListParams contains parameters of the Repository.GetList
type RepositoryMockGetListParams struct {
	ctx    context.Context
	filter *mm_meeting_repository.Query
}

// RepositoryMockGetListResults contains results of the Repository.GetList
type RepositoryMockGetListResults struct {
	mpa1 []*model.Meeting
	err  error
}

// Expect sets up expected params for Repository.GetList
func (mmGetList *mRepositoryMockGetList) Expect(ctx context.Context, filter *mm_meeting_repository.Query) *mRepositoryMockGetList {
	if mmGetList.mock.funcGetList != nil {
		mmGetList.mock.t.Fatalf("RepositoryMock.GetList mock is already set by Set")
	}

	if mmGetList.defaultExpectation == nil {
		mmGetList.defaultExpectation = &RepositoryMockGetListExpectation{}
	}

	mmGetList.defaultExpectation.params = &RepositoryMockGetListParams{ctx, filter}
	for _, e := range mmGetList.expectations {
		if minimock.Equal(e.params, mmGetList.defaultExpectation.params) {
			mmGetList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetList.defaultExpectation.params)
		}
	}

	return mmGetList
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetList
func (mmGetList *mRepositoryMockGetList) Inspect(f func(ctx context.Context, filter *mm_meeting_repository.Query)) *mRepositoryMockGetList {
	if mmGetList.mock.inspectFuncGetList != nil {
		mmGetList.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetList")
	}

	mmGetList.mock.inspectFuncGetList = f

	return mmGetList
}

// Return sets up results that will be returned by Repository.GetList
func (mmGetList *mRepositoryMockGetList) Return(mpa1 []*model.Meeting, err error) *RepositoryMock {
	if mmGetList.mock.funcGetList != nil {
		mmGetList.mock.t.Fatalf("RepositoryMock.GetList mock is already set by Set")
	}

	if mmGetList.defaultExpectation == nil {
		mmGetList.defaultExpectation = &RepositoryMockGetListExpectation{mock: mmGetList.mock}
	}
	mmGetList.defaultExpectation.results = &RepositoryMockGetListResults{mpa1, err}
	return mmGetList.mock
}

//Set uses given function f to mock the Repository.GetList method
func (mmGetList *mRepositoryMockGetList) Set(f func(ctx context.Context, filter *mm_meeting_repository.Query) (mpa1 []*model.Meeting, err error)) *RepositoryMock {
	if mmGetList.defaultExpectation != nil {
		mmGetList.mock.t.Fatalf("Default expectation is already set for the Repository.GetList method")
	}

	if len(mmGetList.expectations) > 0 {
		mmGetList.mock.t.Fatalf("Some expectations are already set for the Repository.GetList method")
	}

	mmGetList.mock.funcGetList = f
	return mmGetList.mock
}

// When sets expectation for the Repository.GetList which will trigger the result defined by the following
// Then helper
func (mmGetList *mRepositoryMockGetList) When(ctx context.Context, filter *mm_meeting_repository.Query) *RepositoryMockGetListExpectation {
	if mmGetList.mock.funcGetList != nil {
		mmGetList.mock.t.Fatalf("RepositoryMock.GetList mock is already set by Set")
	}

	expectation := &RepositoryMockGetListExpectation{
		mock:   mmGetList.mock,
		params: &RepositoryMockGetListParams{ctx, filter},
	}
	mmGetList.expectations = append(mmGetList.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetList return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetListExpectation) Then(mpa1 []*model.Meeting, err error) *RepositoryMock {
	e.results = &RepositoryMockGetListResults{mpa1, err}
	return e.mock
}

// GetList implements meeting_repository.Repository
func (mmGetList *RepositoryMock) GetList(ctx context.Context, filter *mm_meeting_repository.Query) (mpa1 []*model.Meeting, err error) {
	mm_atomic.AddUint64(&mmGetList.beforeGetListCounter, 1)
	defer mm_atomic.AddUint64(&mmGetList.afterGetListCounter, 1)

	if mmGetList.inspectFuncGetList != nil {
		mmGetList.inspectFuncGetList(ctx, filter)
	}

	mm_params := &RepositoryMockGetListParams{ctx, filter}

	// Record call args
	mmGetList.GetListMock.mutex.Lock()
	mmGetList.GetListMock.callArgs = append(mmGetList.GetListMock.callArgs, mm_params)
	mmGetList.GetListMock.mutex.Unlock()

	for _, e := range mmGetList.GetListMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mpa1, e.results.err
		}
	}

	if mmGetList.GetListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetList.GetListMock.defaultExpectation.Counter, 1)
		mm_want := mmGetList.GetListMock.defaultExpectation.params
		mm_got := RepositoryMockGetListParams{ctx, filter}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetList.t.Errorf("RepositoryMock.GetList got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetList.GetListMock.defaultExpectation.results
		if mm_results == nil {
			mmGetList.t.Fatal("No results are set for the RepositoryMock.GetList")
		}
		return (*mm_results).mpa1, (*mm_results).err
	}
	if mmGetList.funcGetList != nil {
		return mmGetList.funcGetList(ctx, filter)
	}
	mmGetList.t.Fatalf("Unexpected call to RepositoryMock.GetList. %v %v", ctx, filter)
	return
}

// GetListAfterCounter returns a count of finished RepositoryMock.GetList invocations
func (mmGetList *RepositoryMock) GetListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetList.afterGetListCounter)
}

// GetListBeforeCounter returns a count of RepositoryMock.GetList invocations
func (mmGetList *RepositoryMock) GetListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetList.beforeGetListCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetList *mRepositoryMockGetList) Calls() []*RepositoryMockGetListParams {
	mmGetList.mutex.RLock()

	argCopy := make([]*RepositoryMockGetListParams, len(mmGetList.callArgs))
	copy(argCopy, mmGetList.callArgs)

	mmGetList.mutex.RUnlock()

	return argCopy
}

// MinimockGetListDone returns true if the count of the GetList invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetListDone() bool {
	for _, e := range m.GetListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetList != nil && mm_atomic.LoadUint64(&m.afterGetListCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetListInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetListInspect() {
	for _, e := range m.GetListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetList with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListCounter) < 1 {
		if m.GetListMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetList")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetList with params: %#v", *m.GetListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetList != nil && mm_atomic.LoadUint64(&m.afterGetListCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetList")
	}
}

type mRepositoryMockGetSpeakerCountByTopic struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetSpeakerCountByTopicExpectation
	expectations       []*RepositoryMockGetSpeakerCountByTopicExpectation

	callArgs []*RepositoryMockGetSpeakerCountByTopicParams
	mutex    sync.RWMutex
}

// RepositoryMockGetSpeakerCountByTopicExpectation specifies expectation struct of the Repository.GetSpeakerCountByTopic
type RepositoryMockGetSpeakerCountByTopicExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockGetSpeakerCountByTopicParams
	results *RepositoryMockGetSpeakerCountByTopicResults
	Counter uint64
}

// RepositoryMockGetSpeakerCountByTopicParams contains parameters of the Repository.GetSpeakerCountByTopic
type RepositoryMockGetSpeakerCountByTopicParams struct {
	ctx       context.Context
	topicID   int64
	speakerID int64
}

// RepositoryMockGetSpeakerCountByTopicResults contains results of the Repository.GetSpeakerCountByTopic
type RepositoryMockGetSpeakerCountByTopicResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for Repository.GetSpeakerCountByTopic
func (mmGetSpeakerCountByTopic *mRepositoryMockGetSpeakerCountByTopic) Expect(ctx context.Context, topicID int64, speakerID int64) *mRepositoryMockGetSpeakerCountByTopic {
	if mmGetSpeakerCountByTopic.mock.funcGetSpeakerCountByTopic != nil {
		mmGetSpeakerCountByTopic.mock.t.Fatalf("RepositoryMock.GetSpeakerCountByTopic mock is already set by Set")
	}

	if mmGetSpeakerCountByTopic.defaultExpectation == nil {
		mmGetSpeakerCountByTopic.defaultExpectation = &RepositoryMockGetSpeakerCountByTopicExpectation{}
	}

	mmGetSpeakerCountByTopic.defaultExpectation.params = &RepositoryMockGetSpeakerCountByTopicParams{ctx, topicID, speakerID}
	for _, e := range mmGetSpeakerCountByTopic.expectations {
		if minimock.Equal(e.params, mmGetSpeakerCountByTopic.defaultExpectation.params) {
			mmGetSpeakerCountByTopic.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetSpeakerCountByTopic.defaultExpectation.params)
		}
	}

	return mmGetSpeakerCountByTopic
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetSpeakerCountByTopic
func (mmGetSpeakerCountByTopic *mRepositoryMockGetSpeakerCountByTopic) Inspect(f func(ctx context.Context, topicID int64, speakerID int64)) *mRepositoryMockGetSpeakerCountByTopic {
	if mmGetSpeakerCountByTopic.mock.inspectFuncGetSpeakerCountByTopic != nil {
		mmGetSpeakerCountByTopic.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetSpeakerCountByTopic")
	}

	mmGetSpeakerCountByTopic.mock.inspectFuncGetSpeakerCountByTopic = f

	return mmGetSpeakerCountByTopic
}

// Return sets up results that will be returned by Repository.GetSpeakerCountByTopic
func (mmGetSpeakerCountByTopic *mRepositoryMockGetSpeakerCountByTopic) Return(i1 int64, err error) *RepositoryMock {
	if mmGetSpeakerCountByTopic.mock.funcGetSpeakerCountByTopic != nil {
		mmGetSpeakerCountByTopic.mock.t.Fatalf("RepositoryMock.GetSpeakerCountByTopic mock is already set by Set")
	}

	if mmGetSpeakerCountByTopic.defaultExpectation == nil {
		mmGetSpeakerCountByTopic.defaultExpectation = &RepositoryMockGetSpeakerCountByTopicExpectation{mock: mmGetSpeakerCountByTopic.mock}
	}
	mmGetSpeakerCountByTopic.defaultExpectation.results = &RepositoryMockGetSpeakerCountByTopicResults{i1, err}
	return mmGetSpeakerCountByTopic.mock
}

//Set uses given function f to mock the Repository.GetSpeakerCountByTopic method
func (mmGetSpeakerCountByTopic *mRepositoryMockGetSpeakerCountByTopic) Set(f func(ctx context.Context, topicID int64, speakerID int64) (i1 int64, err error)) *RepositoryMock {
	if mmGetSpeakerCountByTopic.defaultExpectation != nil {
		mmGetSpeakerCountByTopic.mock.t.Fatalf("Default expectation is already set for the Repository.GetSpeakerCountByTopic method")
	}

	if len(mmGetSpeakerCountByTopic.expectations) > 0 {
		mmGetSpeakerCountByTopic.mock.t.Fatalf("Some expectations are already set for the Repository.GetSpeakerCountByTopic method")
	}

	mmGetSpeakerCountByTopic.mock.funcGetSpeakerCountByTopic = f
	return mmGetSpeakerCountByTopic.mock
}

// When sets expectation for the Repository.GetSpeakerCountByTopic which will trigger the result defined by the following
// Then helper
func (mmGetSpeakerCountByTopic *mRepositoryMockGetSpeakerCountByTopic) When(ctx context.Context, topicID int64, speakerID int64) *RepositoryMockGetSpeakerCountByTopicExpectation {
	if mmGetSpeakerCountByTopic.mock.funcGetSpeakerCountByTopic != nil {
		mmGetSpeakerCountByTopic.mock.t.Fatalf("RepositoryMock.GetSpeakerCountByTopic mock is already set by Set")
	}

	expectation := &RepositoryMockGetSpeakerCountByTopicExpectation{
		mock:   mmGetSpeakerCountByTopic.mock,
		params: &RepositoryMockGetSpeakerCountByTopicParams{ctx, topicID, speakerID},
	}
	mmGetSpeakerCountByTopic.expectations = append(mmGetSpeakerCountByTopic.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetSpeakerCountByTopic return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetSpeakerCountByTopicExpectation) Then(i1 int64, err error) *RepositoryMock {
	e.results = &RepositoryMockGetSpeakerCountByTopicResults{i1, err}
	return e.mock
}

// GetSpeakerCountByTopic implements meeting_repository.Repository
func (mmGetSpeakerCountByTopic *RepositoryMock) GetSpeakerCountByTopic(ctx context.Context, topicID int64, speakerID int64) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmGetSpeakerCountByTopic.beforeGetSpeakerCountByTopicCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSpeakerCountByTopic.afterGetSpeakerCountByTopicCounter, 1)

	if mmGetSpeakerCountByTopic.inspectFuncGetSpeakerCountByTopic != nil {
		mmGetSpeakerCountByTopic.inspectFuncGetSpeakerCountByTopic(ctx, topicID, speakerID)
	}

	mm_params := &RepositoryMockGetSpeakerCountByTopicParams{ctx, topicID, speakerID}

	// Record call args
	mmGetSpeakerCountByTopic.GetSpeakerCountByTopicMock.mutex.Lock()
	mmGetSpeakerCountByTopic.GetSpeakerCountByTopicMock.callArgs = append(mmGetSpeakerCountByTopic.GetSpeakerCountByTopicMock.callArgs, mm_params)
	mmGetSpeakerCountByTopic.GetSpeakerCountByTopicMock.mutex.Unlock()

	for _, e := range mmGetSpeakerCountByTopic.GetSpeakerCountByTopicMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetSpeakerCountByTopic.GetSpeakerCountByTopicMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSpeakerCountByTopic.GetSpeakerCountByTopicMock.defaultExpectation.Counter, 1)
		mm_want := mmGetSpeakerCountByTopic.GetSpeakerCountByTopicMock.defaultExpectation.params
		mm_got := RepositoryMockGetSpeakerCountByTopicParams{ctx, topicID, speakerID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetSpeakerCountByTopic.t.Errorf("RepositoryMock.GetSpeakerCountByTopic got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetSpeakerCountByTopic.GetSpeakerCountByTopicMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSpeakerCountByTopic.t.Fatal("No results are set for the RepositoryMock.GetSpeakerCountByTopic")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetSpeakerCountByTopic.funcGetSpeakerCountByTopic != nil {
		return mmGetSpeakerCountByTopic.funcGetSpeakerCountByTopic(ctx, topicID, speakerID)
	}
	mmGetSpeakerCountByTopic.t.Fatalf("Unexpected call to RepositoryMock.GetSpeakerCountByTopic. %v %v %v", ctx, topicID, speakerID)
	return
}

// GetSpeakerCountByTopicAfterCounter returns a count of finished RepositoryMock.GetSpeakerCountByTopic invocations
func (mmGetSpeakerCountByTopic *RepositoryMock) GetSpeakerCountByTopicAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSpeakerCountByTopic.afterGetSpeakerCountByTopicCounter)
}

// GetSpeakerCountByTopicBeforeCounter returns a count of RepositoryMock.GetSpeakerCountByTopic invocations
func (mmGetSpeakerCountByTopic *RepositoryMock) GetSpeakerCountByTopicBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSpeakerCountByTopic.beforeGetSpeakerCountByTopicCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetSpeakerCountByTopic.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetSpeakerCountByTopic *mRepositoryMockGetSpeakerCountByTopic) Calls() []*RepositoryMockGetSpeakerCountByTopicParams {
	mmGetSpeakerCountByTopic.mutex.RLock()

	argCopy := make([]*RepositoryMockGetSpeakerCountByTopicParams, len(mmGetSpeakerCountByTopic.callArgs))
	copy(argCopy, mmGetSpeakerCountByTopic.callArgs)

	mmGetSpeakerCountByTopic.mutex.RUnlock()

	return argCopy
}

// MinimockGetSpeakerCountByTopicDone returns true if the count of the GetSpeakerCountByTopic invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetSpeakerCountByTopicDone() bool {
	for _, e := range m.GetSpeakerCountByTopicMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSpeakerCountByTopicMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSpeakerCountByTopicCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSpeakerCountByTopic != nil && mm_atomic.LoadUint64(&m.afterGetSpeakerCountByTopicCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetSpeakerCountByTopicInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetSpeakerCountByTopicInspect() {
	for _, e := range m.GetSpeakerCountByTopicMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetSpeakerCountByTopic with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSpeakerCountByTopicMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSpeakerCountByTopicCounter) < 1 {
		if m.GetSpeakerCountByTopicMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetSpeakerCountByTopic")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetSpeakerCountByTopic with params: %#v", *m.GetSpeakerCountByTopicMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSpeakerCountByTopic != nil && mm_atomic.LoadUint64(&m.afterGetSpeakerCountByTopicCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetSpeakerCountByTopic")
	}
}

type mRepositoryMockGetSpeakersStats struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetSpeakersStatsExpectation
	expectations       []*RepositoryMockGetSpeakersStatsExpectation

	callArgs []*RepositoryMockGetSpeakersStatsParams
	mutex    sync.RWMutex
}

// RepositoryMockGetSpeakersStatsExpectation specifies expectation struct of the Repository.GetSpeakersStats
type RepositoryMockGetSpeakersStatsExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockGetSpeakersStatsParams
	results *RepositoryMockGetSpeakersStatsResults
	Counter uint64
}

// RepositoryMockGetSpeakersStatsParams contains parameters of the Repository.GetSpeakersStats
type RepositoryMockGetSpeakersStatsParams struct {
	ctx              context.Context
	topicID          int64
	excludeSpeakerID int64
}

// RepositoryMockGetSpeakersStatsResults contains results of the Repository.GetSpeakersStats
type RepositoryMockGetSpeakersStatsResults struct {
	spa1 []*model.Stats
	err  error
}

// Expect sets up expected params for Repository.GetSpeakersStats
func (mmGetSpeakersStats *mRepositoryMockGetSpeakersStats) Expect(ctx context.Context, topicID int64, excludeSpeakerID int64) *mRepositoryMockGetSpeakersStats {
	if mmGetSpeakersStats.mock.funcGetSpeakersStats != nil {
		mmGetSpeakersStats.mock.t.Fatalf("RepositoryMock.GetSpeakersStats mock is already set by Set")
	}

	if mmGetSpeakersStats.defaultExpectation == nil {
		mmGetSpeakersStats.defaultExpectation = &RepositoryMockGetSpeakersStatsExpectation{}
	}

	mmGetSpeakersStats.defaultExpectation.params = &RepositoryMockGetSpeakersStatsParams{ctx, topicID, excludeSpeakerID}
	for _, e := range mmGetSpeakersStats.expectations {
		if minimock.Equal(e.params, mmGetSpeakersStats.defaultExpectation.params) {
			mmGetSpeakersStats.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetSpeakersStats.defaultExpectation.params)
		}
	}

	return mmGetSpeakersStats
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetSpeakersStats
func (mmGetSpeakersStats *mRepositoryMockGetSpeakersStats) Inspect(f func(ctx context.Context, topicID int64, excludeSpeakerID int64)) *mRepositoryMockGetSpeakersStats {
	if mmGetSpeakersStats.mock.inspectFuncGetSpeakersStats != nil {
		mmGetSpeakersStats.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetSpeakersStats")
	}

	mmGetSpeakersStats.mock.inspectFuncGetSpeakersStats = f

	return mmGetSpeakersStats
}

// Return sets up results that will be returned by Repository.GetSpeakersStats
func (mmGetSpeakersStats *mRepositoryMockGetSpeakersStats) Return(spa1 []*model.Stats, err error) *RepositoryMock {
	if mmGetSpeakersStats.mock.funcGetSpeakersStats != nil {
		mmGetSpeakersStats.mock.t.Fatalf("RepositoryMock.GetSpeakersStats mock is already set by Set")
	}

	if mmGetSpeakersStats.defaultExpectation == nil {
		mmGetSpeakersStats.defaultExpectation = &RepositoryMockGetSpeakersStatsExpectation{mock: mmGetSpeakersStats.mock}
	}
	mmGetSpeakersStats.defaultExpectation.results = &RepositoryMockGetSpeakersStatsResults{spa1, err}
	return mmGetSpeakersStats.mock
}

//Set uses given function f to mock the Repository.GetSpeakersStats method
func (mmGetSpeakersStats *mRepositoryMockGetSpeakersStats) Set(f func(ctx context.Context, topicID int64, excludeSpeakerID int64) (spa1 []*model.Stats, err error)) *RepositoryMock {
	if mmGetSpeakersStats.defaultExpectation != nil {
		mmGetSpeakersStats.mock.t.Fatalf("Default expectation is already set for the Repository.GetSpeakersStats method")
	}

	if len(mmGetSpeakersStats.expectations) > 0 {
		mmGetSpeakersStats.mock.t.Fatalf("Some expectations are already set for the Repository.GetSpeakersStats method")
	}

	mmGetSpeakersStats.mock.funcGetSpeakersStats = f
	return mmGetSpeakersStats.mock
}

// When sets expectation for the Repository.GetSpeakersStats which will trigger the result defined by the following
// Then helper
func (mmGetSpeakersStats *mRepositoryMockGetSpeakersStats) When(ctx context.Context, topicID int64, excludeSpeakerID int64) *RepositoryMockGetSpeakersStatsExpectation {
	if mmGetSpeakersStats.mock.funcGetSpeakersStats != nil {
		mmGetSpeakersStats.mock.t.Fatalf("RepositoryMock.GetSpeakersStats mock is already set by Set")
	}

	expectation := &RepositoryMockGetSpeakersStatsExpectation{
		mock:   mmGetSpeakersStats.mock,
		params: &RepositoryMockGetSpeakersStatsParams{ctx, topicID, excludeSpeakerID},
	}
	mmGetSpeakersStats.expectations = append(mmGetSpeakersStats.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetSpeakersStats return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetSpeakersStatsExpectation) Then(spa1 []*model.Stats, err error) *RepositoryMock {
	e.results = &RepositoryMockGetSpeakersStatsResults{spa1, err}
	return e.mock
}

// GetSpeakersStats implements meeting_repository.Repository
func (mmGetSpeakersStats *RepositoryMock) GetSpeakersStats(ctx context.Context, topicID int64, excludeSpeakerID int64) (spa1 []*model.Stats, err error) {
	mm_atomic.AddUint64(&mmGetSpeakersStats.beforeGetSpeakersStatsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSpeakersStats.afterGetSpeakersStatsCounter, 1)

	if mmGetSpeakersStats.inspectFuncGetSpeakersStats != nil {
		mmGetSpeakersStats.inspectFuncGetSpeakersStats(ctx, topicID, excludeSpeakerID)
	}

	mm_params := &RepositoryMockGetSpeakersStatsParams{ctx, topicID, excludeSpeakerID}

	// Record call args
	mmGetSpeakersStats.GetSpeakersStatsMock.mutex.Lock()
	mmGetSpeakersStats.GetSpeakersStatsMock.callArgs = append(mmGetSpeakersStats.GetSpeakersStatsMock.callArgs, mm_params)
	mmGetSpeakersStats.GetSpeakersStatsMock.mutex.Unlock()

	for _, e := range mmGetSpeakersStats.GetSpeakersStatsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.spa1, e.results.err
		}
	}

	if mmGetSpeakersStats.GetSpeakersStatsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSpeakersStats.GetSpeakersStatsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetSpeakersStats.GetSpeakersStatsMock.defaultExpectation.params
		mm_got := RepositoryMockGetSpeakersStatsParams{ctx, topicID, excludeSpeakerID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetSpeakersStats.t.Errorf("RepositoryMock.GetSpeakersStats got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetSpeakersStats.GetSpeakersStatsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSpeakersStats.t.Fatal("No results are set for the RepositoryMock.GetSpeakersStats")
		}
		return (*mm_results).spa1, (*mm_results).err
	}
	if mmGetSpeakersStats.funcGetSpeakersStats != nil {
		return mmGetSpeakersStats.funcGetSpeakersStats(ctx, topicID, excludeSpeakerID)
	}
	mmGetSpeakersStats.t.Fatalf("Unexpected call to RepositoryMock.GetSpeakersStats. %v %v %v", ctx, topicID, excludeSpeakerID)
	return
}

// GetSpeakersStatsAfterCounter returns a count of finished RepositoryMock.GetSpeakersStats invocations
func (mmGetSpeakersStats *RepositoryMock) GetSpeakersStatsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSpeakersStats.afterGetSpeakersStatsCounter)
}

// GetSpeakersStatsBeforeCounter returns a count of RepositoryMock.GetSpeakersStats invocations
func (mmGetSpeakersStats *RepositoryMock) GetSpeakersStatsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSpeakersStats.beforeGetSpeakersStatsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetSpeakersStats.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetSpeakersStats *mRepositoryMockGetSpeakersStats) Calls() []*RepositoryMockGetSpeakersStatsParams {
	mmGetSpeakersStats.mutex.RLock()

	argCopy := make([]*RepositoryMockGetSpeakersStatsParams, len(mmGetSpeakersStats.callArgs))
	copy(argCopy, mmGetSpeakersStats.callArgs)

	mmGetSpeakersStats.mutex.RUnlock()

	return argCopy
}

// MinimockGetSpeakersStatsDone returns true if the count of the GetSpeakersStats invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetSpeakersStatsDone() bool {
	for _, e := range m.GetSpeakersStatsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSpeakersStatsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSpeakersStatsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSpeakersStats != nil && mm_atomic.LoadUint64(&m.afterGetSpeakersStatsCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetSpeakersStatsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetSpeakersStatsInspect() {
	for _, e := range m.GetSpeakersStatsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetSpeakersStats with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSpeakersStatsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSpeakersStatsCounter) < 1 {
		if m.GetSpeakersStatsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetSpeakersStats")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetSpeakersStats with params: %#v", *m.GetSpeakersStatsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSpeakersStats != nil && mm_atomic.LoadUint64(&m.afterGetSpeakersStatsCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetSpeakersStats")
	}
}

type mRepositoryMockUpdate struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateExpectation
	expectations       []*RepositoryMockUpdateExpectation

	callArgs []*RepositoryMockUpdateParams
	mutex    sync.RWMutex
}

// RepositoryMockUpdateExpectation specifies expectation struct of the Repository.Update
type RepositoryMockUpdateExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockUpdateParams
	results *RepositoryMockUpdateResults
	Counter uint64
}

// RepositoryMockUpdateParams contains parameters of the Repository.Update
type RepositoryMockUpdateParams struct {
	ctx           context.Context
	ids           []int64
	updateMeeting *model.UpdateMeeting
}

// RepositoryMockUpdateResults contains results of the Repository.Update
type RepositoryMockUpdateResults struct {
	err error
}

// Expect sets up expected params for Repository.Update
func (mmUpdate *mRepositoryMockUpdate) Expect(ctx context.Context, ids []int64, updateMeeting *model.UpdateMeeting) *mRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("RepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &RepositoryMockUpdateExpectation{}
	}

	mmUpdate.defaultExpectation.params = &RepositoryMockUpdateParams{ctx, ids, updateMeeting}
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the Repository.Update
func (mmUpdate *mRepositoryMockUpdate) Inspect(f func(ctx context.Context, ids []int64, updateMeeting *model.UpdateMeeting)) *mRepositoryMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for RepositoryMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by Repository.Update
func (mmUpdate *mRepositoryMockUpdate) Return(err error) *RepositoryMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("RepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &RepositoryMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &RepositoryMockUpdateResults{err}
	return mmUpdate.mock
}

//Set uses given function f to mock the Repository.Update method
func (mmUpdate *mRepositoryMockUpdate) Set(f func(ctx context.Context, ids []int64, updateMeeting *model.UpdateMeeting) (err error)) *RepositoryMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the Repository.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the Repository.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	return mmUpdate.mock
}

// When sets expectation for the Repository.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mRepositoryMockUpdate) When(ctx context.Context, ids []int64, updateMeeting *model.UpdateMeeting) *RepositoryMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("RepositoryMock.Update mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateExpectation{
		mock:   mmUpdate.mock,
		params: &RepositoryMockUpdateParams{ctx, ids, updateMeeting},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up Repository.Update return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateResults{err}
	return e.mock
}

// Update implements meeting_repository.Repository
func (mmUpdate *RepositoryMock) Update(ctx context.Context, ids []int64, updateMeeting *model.UpdateMeeting) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, ids, updateMeeting)
	}

	mm_params := &RepositoryMockUpdateParams{ctx, ids, updateMeeting}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_got := RepositoryMockUpdateParams{ctx, ids, updateMeeting}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("RepositoryMock.Update got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the RepositoryMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, ids, updateMeeting)
	}
	mmUpdate.t.Fatalf("Unexpected call to RepositoryMock.Update. %v %v %v", ctx, ids, updateMeeting)
	return
}

// UpdateAfterCounter returns a count of finished RepositoryMock.Update invocations
func (mmUpdate *RepositoryMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of RepositoryMock.Update invocations
func (mmUpdate *RepositoryMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mRepositoryMockUpdate) Calls() []*RepositoryMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateDone() bool {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.Update with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.Update")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.Update with params: %#v", *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.Update")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateInspect()

		m.MinimockGetInspect()

		m.MinimockGetListInspect()

		m.MinimockGetSpeakerCountByTopicInspect()

		m.MinimockGetSpeakersStatsInspect()

		m.MinimockUpdateInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockGetDone() &&
		m.MinimockGetListDone() &&
		m.MinimockGetSpeakerCountByTopicDone() &&
		m.MinimockGetSpeakersStatsDone() &&
		m.MinimockUpdateDone()
}
